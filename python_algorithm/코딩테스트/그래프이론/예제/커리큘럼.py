# 230801


# 커리큘럼

# N개의 강의를 들을 때 선수 과목 존재, 선수 과목을 포함하여 해당 과정을 들을 때 최소 시간 


# 입력 조건
# 첫째 줄에 듣고자 하는 가으이의 수 n
# 다음 n개의 줄에는 각 강의의 강의 시간과 그 강의를 듣기 위해 먼저 들어야 하는 강의들의 번호가 자연수로 주어지며, 각 자연수는 공백으로 구분한다. 이때 강의 시간은 100000 이하의 자연수이다.
# 각 강의 번호는 1부터 N까지로 구성되며 , 각 줄은 -1로 끝낸다.


# 출력조건
# N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다.


# 문제 해설
# 이 문제는 위상 정렬 알고리즘 응ㅇ용
# 강의에 대하여 인접한 노드를 확인할 때, 인접한 노드에 대하여 현재보다. 가으이 시간이 더 긴 경우를 찾는다면, 더 오랜 시간이 걸리는 경우의 시간 값을 저장하는 방식으로 결과 테이블을 갱신하여 답을 구할 수 있다.
# 따라서 위상 정렬을 수행하면서, 매번 간선ㄴ 정보를 확인하여 결과 테이블을 갱신한다.

# 포인트? deepcopy() 함수를 이용하여 time리스트 변수의 값을 복사하여 result 리스트 변수의 값으로 설정하는 작업이 수행된다.


# deepcopy() -> 깊은 복사 --> 서로 독립적으로 존재 
# 1. 객체의 중첩 구조 복사 : 객체가 다른 객체들을 포함하고 있을 때, 얕은 복사를 사용하면 포함된 객체들은 원본과 복사본이 같은 객체를 참조하게 된다. 그러나 깊은 복사를 사용하면 모든 포함된 객체들도 새로운 복사본을 가지게 되어 원본과 독립적인 상태가 된다.
# 2. 데이터 불변성 보장 : 데이터가 중첩되어 있는 경우 얕은 복사를 사용하면 데이터 변경이 예상치 못하게 전파될 수 있다. 하지만 깊은 복사를 사용하면 원본 데이터의 불변성을 보장함녀서 복사본에서 자유롭게 수정할 수 있다.
# 3. 객체의 독립성 유지 : 깊은 복사를 통해 각 객체들이 서로 독립적으로 유지. 이는 프로그래밍에서 유용한 개념으로, 원본 객체를 변경해야 하는 경우 깊은 복사본을 사용하여 원본의 불변성을 유지하고 새로운 변경 가능한 복사본을 작업에 사용

from collections import deque
import copy

# 노드의 개수 
v = int(input())

# 모든 노드에 대한 진입차수는 0으로 초기화
indegree = [0] * (v+1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
graph = [[] for i in range(v+1)]
# 각 강의 시간을 0으로 초기화
time = [0] * (v+1)

# 방향 그래프의 모든 간선 정보를 입력 받기
for i in range(1,v+1):
    data = list(map(int,input().split()))
    time[i] = data[0]
    # 간선의 연결된 간선 수 카운트
    for x in data[1:]:
        indegree[x] +=1 
        graph[x].append(i)


# 위상 정렬 함수
def topologySort():
    result = copy.deepcopy(time) # 알고리즘 수행 결과를 담을 리스트
    q = deque()
    # 처음  시작할 때는 진입차수가 0인 노드를 큐에 삽입
    for i  in range(1,v+1):
        if indegree[i] == 0 :
            q.append(i)
    
    while q:
        now = q.popleft()
        # 현재 원소와 연결된 노드들의 진입차수에서 1 제외
        for i in graph[now]:
            result[i] = max(result[i],result[now] + time[i])
            indegree[i] -= 1 
            if indegree[i] == 0 :
                q.append(i)

    # 위상 정렬 수행 결과 
    for i in range(1, v+1):
        print(result[i])

topologySort()